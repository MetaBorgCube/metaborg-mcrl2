module statics/constraints/subtyping

imports

  signatures/-

  analysis
  statics/-
  statics/declarative/-
  statics/constraints/-
  pp

rules

  pos-vars: FORALL(V*, T) -> <fatal-err(|"Cannot check polarity of type schemes")>

  pos-vars: FUNCTION(T1*, T2) -> <conc> (V1*, V2*)
    with
      V1* := <mapconcat(neg-vars)> T1*
    ; V2* := <pos-vars> T2

  pos-vars: PRODUCT(T*) -> V*
    with
      V* := <mapconcat(pos-vars)> T*

  pos-vars: LIST(T) -> V*
    with
      V* := <pos-vars> T

  pos-vars: SET(T) -> V*
    with
      V* := <pos-vars> T

  pos-vars: BAG(T) -> V*
    with
      V* := <pos-vars> T

  pos-vars: V -> [V]
    where <is-var> V

  pos-vars: T -> []

rules

  neg-vars: FORALL(V*, T) -> <fatal-err(|"Cannot check polarity of type schemes")>

  neg-vars: FUNCTION(T1*, T2) -> <conc> (V1*, V2*)
    with
      V1* := <mapconcat(pos-vars)> T1*
    ; V2* := <neg-vars> T2

  neg-vars: PRODUCT(T*) -> V*
    with
      V* := <mapconcat(neg-vars)> T*

  neg-vars: LIST(T) -> V*
    with
      V* := <neg-vars> T

  neg-vars: SET(T) -> V*
    with
      V* := <neg-vars> T

  neg-vars: BAG(T) -> V*
    with
      V* := <neg-vars> T

  neg-vars: V -> []
    where <is-var> V

  neg-vars: T -> []

rules

  bot-decompose: BOOL() -> BOOL()

  bot-decompose: T -> T'
    with
      N* := <number-types>
    where
      <get-index> (T, N*)
    ; T' := <Hd> N*

  bot-decompose: LIST(_) -> LIST(V)
    with
      V := NVAR(<newname> "bot")

  bot-decompose: SET(_) -> SET(V)
    with
      V := NVAR(<newname> "bot")

  bot-decompose: BAG(_) -> BAG(V)
    with
      V := NVAR(<newname> "bot")

  bot-decompose: NAMED(x) -> NAMED(x)

  bot-decompose: FUNCTION(T1*, _) -> FUNCTION(V1*, V2)
    with
      V1* := <map(!PVAR(<newname> "bot"))> T1*
    ; V2  := NVAR(<newname> "bot")

  bot-decompose: PRODUCT(T*) -> PRODUCT(V*)
    with
      V* := <map(!NVAR(<newname> "bot"))> T*

rules

  top-decompose: BOOL() -> BOOL()

  top-decompose: T -> T'
    with
      N* := <number-types>
    where
      <get-index> (T, N*)
    ; T' := <last> N*

  top-decompose: LIST(_) -> LIST(V)
    with
      V := PVAR(<newname> "top")

  top-decompose: SET(_) -> SET(V)
    with
      V := PVAR(<newname> "top")

  top-decompose: BAG(_) -> BAG(V)
    with
      V := PVAR(<newname> "top")

  top-decompose: NAMED(x) -> NAMED(x)

  top-decompose: FUNCTION(T1*, _) -> FUNCTION(V1*, V2)
    with
      V1* := <map(!NVAR(<newname> "top"))> T1*
    ; V2  := PVAR(<newname> "top")

  top-decompose: PRODUCT(T*) -> PRODUCT(V*)
    with
      V* := <map(!PVAR(<newname> "top"))> T*

rules

  subtype-decompose: (BOOL(), BOOL()) -> []

  subtype-decompose: (T, U) -> []
    with
      N* := <number-types>
    where
      i := <get-index> (T, N*)
    ; j := <get-index> (U, N*)
    ; <leq> (i, j)

  subtype-decompose: (LIST(T), LIST(U)) -> [(T, U)]

  subtype-decompose: (SET(T), SET(U)) -> [(T, U)]

  subtype-decompose: (BAG(T), BAG(U)) -> [(T, U)]

  subtype-decompose: (NAMED(x), NAMED(x)) -> []

  subtype-decompose: (FUNCTION(T1*, T2), FUNCTION(U1*, U2)) -> [(T2, U2)|<zip> (U1*, T1*)]

  subtype-decompose: (PRODUCT(T*), PRODUCT(U*)) -> <zip> (T*, U*)


rules

  // lower bounds are combined with least upper bounds, so results should be positive

  lub-decompose: (BOOL(), BOOL()) -> (BOOL(), [])

  lub-decompose: (T1, T2) -> (T, [])
    with
      N* := <number-types>
    where
      i := <get-index> (T1, N*)
    ; j := <get-index> (T2, N*)
    ; k := <max> (i, j)
    ; T := <index(|k)> N*

  lub-decompose: (LIST(T1), LIST(T2)) -> (LIST(T), C*)
    where
      (T, C*) := <lub-decompose'> (T1, T2)

  lub-decompose: (SET(T1), SET(T2)) -> (SET(T), C*)
    where
      (T, C*) := <lub-decompose'> (T1, T2)

  lub-decompose: (BAG(T1), BAG(T2)) -> (BAG(T), C*)
    where
      (T, C*) := <lub-decompose'> (T1, T2)

  lub-decompose: (NAMED(x), NAMED(x)) -> (NAMED(x), [])

  lub-decompose: (FUNCTION(T11*, T12), FUNCTION(T21*, T22)) -> (FUNCTION(T1*, T2), C*)
    where
      <eq> (<length> T11*, <length> T21*)
    where
      (T1*, C1*) := <glbs-decompose'> (T11*, T21*)
    ; (T2, C2*) := <lub-decompose'> (T12, T22)
    ; C* := [C1*, C2*]

  lub-decompose: (PRODUCT(T1*), PRODUCT(T2*)) -> (PRODUCT(T*), C*)
    where
      <eq> (<length> T1*, <length> T2*)
    where
      (T*, C*) := <lubs-decompose'> (T1*, T2*)


  lubs-decompose' =
    zip(lub-decompose')
  ; unzip
  ; (id, concat)


  lub-decompose': (T1, T2) -> (T, C*)
    where
      if <is-var> T1 + <is-var> T2 then
        T := PVAR(<newname> "lub")
      ; C* := [(T1, T), (T2, T)]
      else
        (T, C*) := <lub-decompose> (T1, T2)
      end

rules

  // upper bounds are combined using greatest lower bound, so results should be negative

  glb-decompose: (BOOL(), BOOL()) -> (BOOL(), [])

  glb-decompose: (T1, T2) -> (T, [])
    with
      N* := <number-types>
    where
      i := <get-index> (T1, N*)
    ; j := <get-index> (T2, N*)
    ; k := <max> (i, j)
    ; T := <index(|k)> N*

  glb-decompose: (LIST(T1), LIST(T2)) -> (LIST(T), C*)
    where
      (T, C*) := <glb-decompose'> (T1, T2)

  glb-decompose: (SET(T1), SET(T2)) -> (SET(T), C*)
    where
      (T, C*) := <glb-decompose'> (T1, T2)

  glb-decompose: (BAG(T1), BAG(T2)) -> (BAG(T), C*)
    where
      (T, C*) := <glb-decompose'> (T1, T2)

  glb-decompose: (NAMED(x), NAMED(x)) -> (NAMED(x), [])

  glb-decompose: (FUNCTION(T11*, T12), FUNCTION(T21*, T22)) -> (FUNCTION(T1*, T2), C*)
    where
      <eq> (<length> T11*, <length> T21*)
    where
      (T1*, C1*) := <lubs-decompose'> (T11*, T21*)
    ; (T2, C2*) := <glb-decompose'> (T12, T22)
    ; C* := [C1*, C2*]

  glb-decompose: (PRODUCT(T1*), PRODUCT(T2*)) -> (PRODUCT(T*), C*)
    where
      <eq> (<length> T1*, <length> T2*)
    where
      (T*, C*) := <glbs-decompose'> (T1*, T2*)


  glbs-decompose' =
    zip(glb-decompose')
  ; unzip
  ; (id, concat)


  glb-decompose': (T1, T2) -> (T, C*)
    where
      if <is-var> T1 + <is-var> T2 then
        T := NVAR(<newname> "glb")
      ; C* := [(T, T1), (T, T2)]
      else
        (T, C*) := <glb-decompose> (T1, T2)
      end
