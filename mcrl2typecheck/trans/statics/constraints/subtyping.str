module statics/constraints/subtyping

imports

  signatures/-

  analysis
  statics/-
  statics/declarative/-
  statics/constraints/-
  pp

rules

  pos-vars: FORALL(V*, T) -> <fatal-err(|"Cannot check polarity of type schemes")>

  pos-vars: FUNCTION(T1*, T2) -> <conc> (V1*, V2*)
    with
      V1* := <mapconcat(neg-vars)> T1*
    ; V2* := <pos-vars> T2

  pos-vars: PRODUCT(T*) -> V*
    with
      V* := <mapconcat(pos-vars)> T*

  pos-vars: LIST(T) -> V*
    with
      V* := <pos-vars> T

  pos-vars: SET(T) -> V*
    with
      V* := <pos-vars> T

  pos-vars: BAG(T) -> V*
    with
      V* := <pos-vars> T

  pos-vars: V -> [V]
    where <is-var> V

  pos-vars: T -> []

rules

  neg-vars: FORALL(V*, T) -> <fatal-err(|"Cannot check polarity of type schemes")>

  neg-vars: FUNCTION(T1*, T2) -> <conc> (V1*, V2*)
    with
      V1* := <mapconcat(pos-vars)> T1*
    ; V2* := <neg-vars> T2

  neg-vars: PRODUCT(T*) -> V*
    with
      V* := <mapconcat(neg-vars)> T*

  neg-vars: LIST(T) -> V*
    with
      V* := <neg-vars> T

  neg-vars: SET(T) -> V*
    with
      V* := <neg-vars> T

  neg-vars: BAG(T) -> V*
    with
      V* := <neg-vars> T

  neg-vars: V -> []
    where <is-var> V

  neg-vars: T -> []

rules

  bot-decompose: BOOL() -> BOOL()

  bot-decompose: T -> T'
    with
      N* := <number-types>
    where
      <get-index> (T, N*)
    ; T' := <Hd> N*

  bot-decompose: LIST(_) -> LIST(V)
    with
      V := NVAR(<newname> "bot")

  bot-decompose: SET(_) -> SET(V)
    with
      V := NVAR(<newname> "bot")

  bot-decompose: BAG(_) -> BAG(V)
    with
      V := NVAR(<newname> "bot")

  bot-decompose: NAMED(x) -> NAMED(x)

  bot-decompose: FUNCTION(T1*, _) -> FUNCTION(V1*, V2)
    with
      V1* := <map(!PVAR(<newname> "bot"))> T1*
    ; V2  := NVAR(<newname> "bot")

  bot-decompose: PRODUCT(T*) -> PRODUCT(V*)
    with
      V* := <map(!NVAR(<newname> "bot"))> T*

rules

  top-decompose: BOOL() -> BOOL()

  top-decompose: T -> T'
    with
      N* := <number-types>
    where
      <get-index> (T, N*)
    ; T' := <last> N*

  top-decompose: LIST(_) -> LIST(V)
    with
      V := PVAR(<newname> "top")

  top-decompose: SET(_) -> SET(V)
    with
      V := PVAR(<newname> "top")

  top-decompose: BAG(_) -> BAG(V)
    with
      V := PVAR(<newname> "top")

  top-decompose: NAMED(x) -> NAMED(x)

  top-decompose: FUNCTION(T1*, _) -> FUNCTION(V1*, V2)
    with
      V1* := <map(!NVAR(<newname> "top"))> T1*
    ; V2  := PVAR(<newname> "top")

  top-decompose: PRODUCT(T*) -> PRODUCT(V*)
    with
      V* := <map(!PVAR(<newname> "top"))> T*

rules

  subtype-decompose: (BOOL(), BOOL()) -> []

  subtype-decompose: (T, U) -> []
    with
      N* := <number-types>
    where
      i := <get-index> (T, N*)
    ; j := <get-index> (U, N*)
    ; <leq> (i, j)

  subtype-decompose: (LIST(T), LIST(U)) -> [(T, U)]

  subtype-decompose: (SET(T), SET(U)) -> [(T, U)]

  subtype-decompose: (BAG(T), BAG(U)) -> [(T, U)]

  subtype-decompose: (NAMED(x), NAMED(x)) -> []

  subtype-decompose: (FUNCTION(T1*, T2), FUNCTION(U1*, U2)) -> [(T2, U2)|<zip> (U1*, T1*)]

  subtype-decompose: (PRODUCT(T*), PRODUCT(U*)) -> <zip> (T*, U*)

rules

  // lower bounds are combined with least upper bounds, so results should be positive

  lub-decompose: (BOOL(), BOOL()) -> (BOOL(), [])

  lub-decompose: (T1, T2) -> (T, [])
    with
      N* := <number-types>
    where
      i := <get-index> (T1, N*)
    ; j := <get-index> (T2, N*)
    ; k := <max> (i, j)
    ; T := <index(|k)> N*

  lub-decompose: (LIST(T1), LIST(T2)) -> (LIST(V), C*)
    with
      V := PVAR(<newname> "lub")
    ; C* := [(T1, V), (T2, V)]

  lub-decompose: (SET(T1), SET(T2)) -> (SET(V), C*)
    with
      V := PVAR(<newname> "lub")
    ; C* := [(T1, V), (T2, V)]

  lub-decompose: (BAG(T1), BAG(T2)) -> (BAG(V), C*)
    with
      V := PVAR(<newname> "lub")
    ; C* := [(T1, V), (T2, V)]

  lub-decompose: (NAMED(x), NAMED(x)) -> (NAMED(x), [])

  lub-decompose: (FUNCTION(T11*, T12), FUNCTION(T21*, T22)) -> (FUNCTION(V1*, V2), C*)
    where
      <eq> (<length> T11*, <length> T21*)
    with
      V1* := <map(!NVAR(<newname> "lub"))> T11*
    ; V2 := PVAR(<newname> "lub")
    ; C1* := <zip> (V1*, T11*)
    ; C2* := <zip> (V1*, T21*)
    ; C* := [(T12, V2), (T22, V2), C1*, C2*]

  lub-decompose: (PRODUCT(T1*), PRODUCT(T2*)) -> (PRODUCT(V*), C*)
    where
      <eq> (<length> T1*, <length> T2*)
    with
      V* := <map(!PVAR(<newname> "lub"))> T1*
    ; C1* := <zip> (T1*, V*)
    ; C2* := <zip> (T2*, V*)
    ; C* := [C1*, C2*]

rules

  // upper bounds are combined using greatest lower bound, so results should be negative

  glb-decompose: (BOOL(), BOOL()) -> (BOOL(), [])

  glb-decompose: (T1, T2) -> (T, [])
    with
      N* := <number-types>
    where
      i := <get-index> (T1, N*)
    ; j := <get-index> (T2, N*)
    ; k := <min> (i, j)
    ; T := <index(|k)> N*

  glb-decompose: (LIST(T1), LIST(T2)) -> (LIST(V), C*)
    with
      V := NVAR(<newname> "glb")
    ; C* := [(V, T1), (V, T2)]

  glb-decompose: (SET(T1), SET(T2)) -> (SET(V), C*)
    with
      V := NVAR(<newname> "glb")
    ; C* := [(V, T1), (V, T2)]

  glb-decompose: (BAG(T1), BAG(T2)) -> (BAG(V), C*)
    with
      V := NVAR(<newname> "glb")
    ; C* := [(V, T1), (V, T2)]

  glb-decompose: (NAMED(x), NAMED(x)) -> (NAMED(x), [])

  glb-decompose: (FUNCTION(T11*, T12), FUNCTION(T21*, T22)) -> (FUNCTION(V1*, V2), C*)
    where
      <eq> (<length> T11*, <length> T21*)
    with
      V1* := <map(!PVAR(<newname> "glb"))> T11*
    ; V2 := NVAR(<newname> "glb")
    ; C1* := <zip> (T11*, V1*)
    ; C2* := <zip> (T21*, V1*)
    ; C* := [(V2, T12), (V2, T22), C1*, C2*]

  glb-decompose: (PRODUCT(T1*), PRODUCT(T2*)) -> (PRODUCT(V*), C*)
    where
      <eq> (<length> T1*, <length> T2*)
    with
      V* := <map(!NVAR(<newname> "glb"))> T1*
    ; C1* := <zip> (V*, T1*)
    ; C2* := <zip> (V*, T2*)
    ; C* := [C1*, C2*]
