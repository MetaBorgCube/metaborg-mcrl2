module statics/constraints/infer-c

imports

  signatures/-
  signatures/mcrl2/-

  analysis
  desugar
  statics/-
  statics/declarative/-
  statics/constraints/-
  pp

rules

  toplevel-infer-expr-c(prune|sort*, map*, var*): e -> D*
    with
      D* := <infer-expr-c(prune|sort*, map*, var*, [])> e

  // @type e -> M([D])
  infer-expr-c(prune|sort*, map*, var*, ctx): e -> D'*
    with
      <log-info(pp-DataExpr-string|"checking ")> e
    ; D* := <infer-expr-c'(prune|sort*, map*, var*, ctx);or-error(|e, "Type error")> e
    ; D'* := <fmap(prune;or-error(|e, "Pruning error"))> D*
    ; <fmap(log-info(pp-Typing-string|"found derivations"))> D'*
    ; <log-info(pp-DataExpr-string|"checked ")> e
    with <fmap(length;AddCount)> D*

rules

  // @type e -> M([D])
  infer-expr-c'(prune|sort*, map*, var*, ctx): e@DataRef(x) -> D*
    with
    C := <init-constraint-store>
  ; ( yT* := <stdlib;getsome(where(?(x, _)));map((id,polarize-scheme))>
    ; D* :=  <map(\ (y, T) -> DC(ctx, e{Type(T), Ref(y)}, T, C, T-DataRef-GlobalMap()) \)> yT*
   <+ yT* := <getsome(where(?(x, _)))> map*
    ; D* := <map(\ (y, T) -> DC(ctx, e{Type(T), Ref(y)}, T, C, T-DataRef-GlobalMap()) \)> yT*
   <+ (y, T) := <getfirst(where(?(x, _)))> var*
    ; D* := [DC(ctx, e{Type(T), Ref(y)}, T, C, T-DataRef-GlobalVar())]
   <+ (y, T) := <getfirst(where(?(x, _)))> ctx
    ; D* := [DC(ctx, e{Type(T), Ref(y)}, T, C, T-DataRef-Local())]
   <+ D* := Errors([(e, $[Unresolved reference [x]])])
    )


  // @type e -> M([D])
  infer-expr-c'(prune|sort*, map*, var*, ctx): e@Number(n) -> D*
    with
      if <string-starts-with(|"-")> n then
        T := INT()
      ; E := T-Number-Int()
      else if <eq> (n, "0") then
        T := NAT()
      ; E := T-Number-Nat()
      else
        T := POS()
      ; E := T-Number-Pos()
      end end
    ; C := <init-constraint-store>
    ; D* := [DC(ctx, e{Type(T)}, T, C, E)]


  // @type e -> M([D])
  infer-expr-c'(prune|sort*, map*, var*, ctx): e@True() -> D*
    with
      T := BOOL()
    ; E := T-True()
    ; C := <init-constraint-store>
    ; D* := [DC(ctx, e{Type(T)}, T, C, E)]


  // @type e -> M([D])
  infer-expr-c'(prune|sort*, map*, var*, ctx): e@False() -> D*
    with
      T := BOOL()
    ; E := T-False()
    ; C := <init-constraint-store>
    ; D* := [DC(ctx, e{Type(T)}, T, C, E)]


  // @type e -> M([D])
  infer-expr-c'(prune|sort*, map*, var*, ctx): e@EmptyList() -> D*
    with
      V := NVAR(<newname> "L")
    ; T := LIST(V)
    ; E := T-EmptyList()
    ; C := <init-constraint-store>
    ; D* := [DC(ctx, e{Type(T)}, T, C, E)]


  // @type e -> M([D])
  infer-expr-c'(prune|sort*, map*, var*, ctx): e@EmptySet() -> D*
    with
      V := NVAR(<newname> "S")
    ; T := SET(V)
    ; E := T-EmptySet()
    ; C := <init-constraint-store>
    ; D* := [DC(ctx, e{Type(T)}, T, C, E)]


  // @type e -> M([D])
  infer-expr-c'(prune|sort*, map*, var*, ctx): e@EmptyBag() -> D*
    with
      V := NVAR(<newname> "B")
    ; T := BAG(V)
    ; E := T-EmptyBag()
    ; C := <init-constraint-store>
    ; D* := [DC(ctx, e{Type(T)}, T, C, E)]


  // @type e -> M([D])
  infer-expr-c'(prune|sort*, map*, var*, ctx): e@ListEnum(e*) -> <or-error(|e, "Incompatible item types")> D*
    with
      Ds* := <map(infer-expr-c(prune|sort*, map*, var*, ctx));fjoin(list-cart)> e*
    ; D* := <fmap(filter(infer-listenum-c(|ctx)))> Ds*

  // @type [D] ~> D
  infer-listenum-c(|ctx): D* -> D
    with
      T* := <map(get-typing-type)> D*
    ; V  := PVAR(<newname> "LE")
    ; C* := <map(get-typing-constraints)> D*
    where
      C  := <merge-constraint-stores> C*
    ; C' := <map(\ T -> (T, V) \);tell-constraint-store(|C)> T*
    with
      U := LIST(V)
    ; D := DC(ctx, ListEnum(<map(get-typing-expr)> D*){Type(U)}, U, C', T-ListEnum(D*))


  // @type e -> M([D])
  infer-expr-c'(prune|sort*, map*, var*, ctx): e@BagEnum(elt*) -> <or-error(|e, "Incompatible item types")> D*
    with
      Delts* := <map(infer-bagenum-c-elt(prune|sort*, map*, var*, ctx));fjoin(list-cart)> elt*
    ; D* := <fmap(filter(infer-bagenum-c(|ctx)))> Delts*

  // @type elt -> M([D])
  infer-bagenum-c-elt(prune|sort*, map*, var*, ctx): BagEnumElt(e1, e2) -> Delt*
    with
      D1* := <infer-expr-c(prune|sort*, map*, var*, ctx)> e1
    ; D2* := <infer-expr-c(prune|sort*, map*, var*, ctx)> e2
    ; Delt* := <fjoin(cart(id))> (D1*, D2*)

  // @type [D] ~> D
  infer-bagenum-c(|ctx): Delt* -> D
    with
      (D1*, D2*) := <unzip> Delt*
    ; T1* := <map(get-typing-type)> D1*
    ; T2* := <map(get-typing-type)> D2*
    ; V := PVAR(<newname> "BE")
    ; C1' := <map(\ T1 -> (T1, V) \)> T1*
    ; C2' := <map(\ T2 -> (T2, NAT()) \)> T2*
    ; C* := <map(get-typing-constraints)> [D1*, D2*]
    where
      C12 := <merge-constraint-stores> C*
    ; C   := <conc;tell-constraint-store(|C12)> (C1', C2')
    with
      elt* := <map(\ (D1, D2) -> BagEnumElt(<get-typing-expr> D1, <get-typing-expr> D2) \)> Delt*
    ; U := BAG(V)
    ; D := DC(ctx, BagEnum(elt*){Type(U)}, U, C, T-BagEnum(Delt*))


  // @type e -> M([D])
  infer-expr-c'(prune|sort*, map*, var*, ctx): e@SetBagComp(vdecl, e') -> <or-error(|e, "Wrong condition type")> D*
    with
      (x, T) := <vardecl-to-var(|sort*)> vdecl
    ; ctx' := [(x, T)|ctx]
    ; D'* := <infer-expr-c(prune|sort*, map*, var*, ctx')> e'
    ; Dset* := <fmap(filter(infer-setcomp-c(|ctx, vdecl, T)))> D'*
    ; Dbag* := <fmap(filter(infer-bagcomp-c(|ctx, vdecl, T)))> D'*
    ; D* := <fjoin(conc)> (Dset*, Dbag*)

  // @type D ~> D
  infer-setcomp-c(|ctx, vdecl, T): D' -> D
    with
      T' := <get-typing-type> D'
    ; C' := <get-typing-constraints> D'
    where
      C := <tell-constraint-store(|C')> [(T',BOOL())]
    with
      U := SET(T)
    ; D := DC(ctx, SetBagComp(vdecl, <get-typing-expr> D'){Type(U)}, U, C, T-SetComp(D'))

  // @type D ~> D
  infer-bagcomp-c(|ctx, vdecl, T): D' -> D
    with
      T' := <get-typing-type> D'
    ; C' := <get-typing-constraints> D'
    where
      C  := <tell-constraint-store(|C')> [(T',NAT())]
    with
      U := BAG(T)
    ; D := DC(ctx, SetBagComp(vdecl, <get-typing-expr> D'){Type(U)}, U, C, T-BagComp(D'))


  // @type e -> M([D])
  infer-expr-c'(prune|sort*, map*, var*, ctx): e@SetEnum(e*) -> <or-error(|e, "Wrong item types")> D*
    with
      Ds* := <map(infer-expr-c(prune|sort*, map*, var*, ctx));fjoin(list-cart)> e*
    ; D* := <fmap(filter(infer-setenum-c(|ctx)))> Ds*

  // @type [D] ~> D
  infer-setenum-c(|ctx): D* -> D
    with
      T* := <map(get-typing-type)> D*
    ; V  := PVAR(<newname> "SE")
    ; C* := <map(get-typing-constraints)> D*
    where
      C  := <merge-constraint-stores> C*
    ; C' := <map(\ T -> (T, V) \);tell-constraint-store(|C)> T*
    with
      U := SET(V)
    ; D := DC(ctx, SetEnum(<map(get-typing-expr)> D*){Type(U)}, U, C', T-SetEnum(D*))


  // @type e -> M([D])
  infer-expr-c'(prune|sort*, map*, var*, ctx): e@FunApp(e1, e2*) -> <or-error(|e, "No matching functions/arguments")> D*
    with
      D1* := <infer-expr-c(prune|sort*, map*, var*, ctx)> e1
    ; D2s* := <map(infer-expr-c(prune|sort*, map*, var*, ctx));fjoin(list-cart)> e2*
    ; D* := <fjoin(join(infer-app-c(|ctx)))> (D1*, D2s*)

  // @type (D, [D]) ~> D
  infer-app-c(|ctx): (D1, D2*) -> D
    with
      [T1|T2*] := <map(get-typing-type)> [D1|D2*]
    ; C* := <map(get-typing-constraints)> [D1|D2*]
    ; V  := PVAR(<newname> "A")
    where
      C  := <merge-constraint-stores> C*
    ; C' := <tell-constraint-store(|C)> [(T1, FUNCTION(T2*, V))]
    with
      D := DC(ctx, FunApp(<get-typing-expr> D1, <map(get-typing-expr)> D2*){Type(V)}, V, C', T-FunApp(D1, D2*))


  // @type e -> M([D])
  infer-expr-c'(prune|sort*, map*, var*, ctx): e@ForAll(vdecls, e') -> <or-error(|e, "Wrong type for body")> D*
    with
      xT* := <map(varsdecl-to-vars(|sort*));concat> vdecls
    ; ctx' := [xT*|ctx]
    ; D'* := <infer-expr-c(prune|sort*, map*, var*, ctx')> e'
    ; D* := <fmap(filter(infer-forall-c(|ctx, vdecls)))> D'*

  // @type D ~> D
  infer-forall-c(|ctx, vdecls): D' -> D
    with
      T' := <get-typing-type> D'
    ; C' := <get-typing-constraints> D'
    where
      C := <tell-constraint-store(|C')> [(T', BOOL())]
    with
      T := BOOL()
    ; D := DC(ctx, ForAll(vdecls, <get-typing-expr> D'){Type(T)}, T, C, T-ForAll(D'))


  // @type e -> M([D])
  infer-expr-c'(prune|sort*, map*, var*, ctx): e@Exists(vdecls, e') -> <or-error(|e, "Wrong type for body")> D*
    with
      xT* := <map(varsdecl-to-vars(|sort*));concat> vdecls
    ; ctx' := [xT*|ctx]
    ; D'* := <infer-expr-c(prune|sort*, map*, var*, ctx')> e'
    ; D* := <fmap(filter(infer-exists-c(|ctx, vdecls)))> D'*

  // @type D ~> D
  infer-exists-c(|ctx, vdecls): D' -> D
    with
      T' := <get-typing-type> D'
    ; C' := <get-typing-constraints> D'
    where
      C := <tell-constraint-store(|C')> [(T', BOOL())]
    with
      T := BOOL()
    ; D := DC(ctx, Exists(vdecls, <get-typing-expr> D'){Type(T)}, T, C, T-Exists(D'))


  // @type e -> M([D])
  infer-expr-c'(prune|sort*, map*, var*, ctx): e@Lambda(vdecls, e') -> <or-error(|e, "Wrong type for body")> D*
    with
      xT1* := <mapconcat(varsdecl-to-vars(|sort*))> vdecls
    ; T1* := <map(Snd)> xT1*
    ; ctx' := [xT1*|ctx]
    ; D'* := <infer-expr-c(prune|sort*, map*, var*, ctx')> e'
    ; D* := <fmap(filter(infer-lam-c(|ctx, vdecls, T1*)))> D'*

  // @type D ~> D
  infer-lam-c(|ctx, vdecls, T1*): D' -> D
    with
      T' := <get-typing-type> D'
    ; C' := <get-typing-constraints> D'
    ; T := FUNCTION(T1*, T')
    ; D := DC(ctx, Lambda(vdecls, <get-typing-expr> D'){Type(T)}, T, C', T-Lambda(D'))


  // @type e -> M([D])
  infer-expr-c'(prune|sort*, map*, var*, ctx): e@Where(e1, a*) -> <or-error(|e, "Type error")> D*
    with
      (x*, e2*) := <map(\ Assign(x, e2) -> (x, e2) \);unzip> a*
    ; D2s* := <map(infer-expr-c(prune|sort*, map*, var*, ctx));fjoin(list-cart)> e2*
    ; D* := <fmap(map(infer-whr-c(prune|sort*, map*, var*, ctx, x*, e1)));fmap(fjoin(concat))> D2s*

  // @type [D] -> M([D])
  infer-whr-c(prune|sort*, map*, var*, ctx, x*, e1): D2* -> <or-error(|e1, "Type error")> D*
    with
      T2* := <map(get-typing-type)> D2*
    ; ctx' := <conc> (<zip> (x*, T2*), ctx)
    ; D1* := <infer-expr-c(prune|sort*, map*, var*, ctx')> e1
    ; D* := <fmap(filter(infer-whr-c-typing(|ctx, x*, D2*)))> D1*

  // @type D -> D
  infer-whr-c-typing(|ctx, x*, D2*):
      D1 -> DC( ctx
              , Where( <get-typing-expr> D1
                , <zip(\ (x, D2) -> Assign(x, <get-typing-expr> D2) \)> (x*, D2*)
                ){Type(T1)}
              , T1
              , C
              , T-Where(D1, D2*)
              )
    with
      T1 := <get-typing-type> D1
    ; T2* := <map(get-typing-type)> D2*
    ; C* := <map(get-typing-constraints)> [D1|D2*]
    where
      C := <merge-constraint-stores> C*
    


  // @type e -> M([D])
  infer-expr-c'(prune|sort*, map*, var*, ctx): As(e, S) -> <or-error(|e, "Cast error")> D*
    with
      D'* := <infer-expr-c(prune|sort*, map*, var*, ctx)> e
    ; if T := <sortref-to-type(|sort*)> S then
        D* := <fmap(filter(infer-as-c(|S, ctx, T)))> D'*
      else
        D* := []
      end

  // @type D ~> D
  infer-as-c(|srt, ctx, T): D' -> D
    with
      T' := <get-typing-type> D'
    ; C' := <get-typing-constraints> D'
    where
      C := <tell-constraint-store(|C')> [(T', T)]
    with
      D := DC(ctx, As(<get-typing-expr> D', srt){Type(T)}, T, C, T-As(D'))
