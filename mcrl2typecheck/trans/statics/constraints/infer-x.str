module statics/constraints/infer-x

imports

  signatures/-
  signatures/mcrl2/-

  analysis
  desugar
  statics/-
  statics/declarative/-
  statics/constraints/-
  pp

rules

  toplevel-infer-expr-x(prune|sort*, map*, var*): e -> D*
    with
      D* := <infer-expr-x(prune|sort*, map*, var*, [])> e

  // @type e -> M([D])
  infer-expr-x(prune|sort*, map*, var*, ctx): e -> D'*
    with
      <log-info(pp-DataExpr-string|"checking ")> e
    ; D* := <infer-expr-x'(prune|sort*, map*, var*, ctx);or-error(|e, "Type error")> e
    ; D'* := <fmap(prune;or-error(|e, "Pruning error"))> D*
    ; <fmap(log-info(pp-Typing-string|"found derivations"))> D'*
    ; <log-info(pp-DataExpr-string|"checked ")> e
    with <fmap(length;AddCount)> D*

rules

  // @type e -> M([D])
  infer-expr-x'(prune|sort*, map*, var*, ctx): e@DataRef(x) -> D*
    with
    ( stdlib;getsome(where(?(x, _)))
    ; D* := Errors([(e, $[Naked reference to built-in [x]])])
   <+ yT* := <getsome(where(?(x, _)))> map*
    ; D* := <map(\ (y, T) -> D(ctx, e{Type(T), Ref(y)}, T, T-DataRef-GlobalMap()) \)> yT*
   <+ (y, T) := <getfirst(where(?(x, _)))> var*
    ; D* := [D(ctx, e{Type(T), Ref(y)}, T, T-DataRef-GlobalVar())]
   <+ (y, T) := <getfirst(where(?(x, _)))> ctx
    ; D* := [D(ctx, e{Type(T), Ref(y)}, T, T-DataRef-Local())]
   <+ D* := Errors([(e, $[Unresolved reference [x]])])
    )


  // @type e -> M([D])
  infer-expr-x'(prune|sort*, map*, var*, ctx): e@Number(n) -> D*
    with
      if <string-starts-with(|"-")> n then
        T := INT()
      ; E := T-Number-Int()
      else if <eq> (n, "0") then
        T := NAT()
      ; E := T-Number-Nat()
      else
        T := POS()
      ; E := T-Number-Pos()
      end end
    ; D* := [D(ctx, e{Type(T)}, T, E)]


  // @type e -> M([D])
  infer-expr-x'(prune|sort*, map*, var*, ctx): e@True() -> D*
    with
      T := BOOL()
    ; E := T-True()
    ; D* := [D(ctx, e{Type(T)}, T, E)]


  // @type e -> M([D])
  infer-expr-x'(prune|sort*, map*, var*, ctx): e@False() -> D*
    with
      T := BOOL()
    ; E := T-False()
    ; D* := [D(ctx, e{Type(T)}, T, E)]


  // @type e -> M([D])
  infer-expr-x'(prune|sort*, map*, var*, ctx): e@EmptyList() -> D*
    with
      T := LIST(BOTTOM())
    ; E := T-EmptyList()
    ; D* := [D(ctx, e{Type(T)}, T, E)]


  // @type e -> M([D])
  infer-expr-x'(prune|sort*, map*, var*, ctx): e@EmptySet() -> D*
    with
      T := SET(BOTTOM())
    ; E := T-EmptySet()
    ; D* := [D(ctx, e{Type(T)}, T, E)]


  // @type e -> M([D])
  infer-expr-x'(prune|sort*, map*, var*, ctx): e@EmptyBag() -> D*
    with
      T := BAG(BOTTOM())
    ; E := T-EmptyBag()
    ; D* := [D(ctx, e{Type(T)}, T, E)]


  // @type e -> M([D])
  infer-expr-x'(prune|sort*, map*, var*, ctx): e@ListEnum(e*) -> <or-error(|e, "Incompatible item types")> D*
    with
      Ds* := <map(infer-expr-x(prune|sort*, map*, var*, ctx));fjoin(list-cart)> e*
    ; D* := <fmap(filter(infer-listenum-x(|ctx)))> Ds*

  // @type [D] ~> D
  infer-listenum-x(|ctx): D* -> D
    with
      T* := <map(get-typing-type)> D*
    where
      T  := <fold1(lub)> T*
    with
      U := LIST(T)
    ; D := D(ctx, ListEnum(<map(get-typing-expr)> D*){Type(U)}, U, T-ListEnum(D*))


  // @type e -> M([D])
  infer-expr-x'(prune|sort*, map*, var*, ctx): e@BagEnum(elt*) -> <or-error(|e, "Incompatible item types")> D*
    with
      Delts* := <map(infer-bagenum-x-elt(prune|sort*, map*, var*, ctx));fjoin(list-cart)> elt*
    ; D* := <fmap(filter(infer-bagenum-x(|ctx)))> Delts*

  // @type elt -> M([D])
  infer-bagenum-x-elt(prune|sort*, map*, var*, ctx): BagEnumElt(e1, e2) -> Delt*
    with
      D1* := <infer-expr-x(prune|sort*, map*, var*, ctx)> e1
    ; D2* := <infer-expr-x(prune|sort*, map*, var*, ctx)> e2
    ; Delt* := <fjoin(cart(id))> (D1*, D2*)

  // @type [D] ~> D
  infer-bagenum-x(|ctx): Delt* -> D
    with
      (D1*, D2*) := <unzip> Delt*
    ; T1* := <map(get-typing-type)> D1*
    ; T2* := <map(get-typing-type)> D2*
    where
      T1 := <fold1(lub)> T1*
    ; <subtypes> (T2*, NAT())
    with
      elt* := <map(\ (D1, D2) -> BagEnumElt(<get-typing-expr> D1, <get-typing-expr> D2) \)> Delt*
    ; U := BAG(T1)
    ; D := D(ctx, BagEnum(elt*){Type(U)}, U, T-BagEnum(Delt*))


  // @type e -> M([D])
  infer-expr-x'(prune|sort*, map*, var*, ctx): e@SetBagComp(vdecl, e') -> <or-error(|e, "Wrong condition type")> D*
    with
      (x, T) := <vardecl-to-var(|sort*)> vdecl
    ; ctx' := [(x, T)|ctx]
    ; D'* := <infer-expr-x(prune|sort*, map*, var*, ctx')> e'
    ; Dset* := <fmap(filter(infer-setcomp-x(|ctx, vdecl, T)))> D'*
    ; Dbag* := <fmap(filter(infer-bagcomp-x(|ctx, vdecl, T)))> D'*
    ; D* := <fjoin(conc)> (Dset*, Dbag*)

  // @type D ~> D
  infer-setcomp-x(|ctx, vdecl, T): D' -> D
    with
      T' := <get-typing-type> D'
    where
      <subtype> (T', BOOL())
    with
      U := SET(T)
    ; D := D(ctx, SetBagComp(vdecl, <get-typing-expr> D'){Type(U)}, U, T-SetComp(D'))

  // @type D ~> D
  infer-bagcomp-x(|ctx, vdecl, T): D' -> D
    with
      T' := <get-typing-type> D'
    where
      <subtype> (T', NAT())
    with
      U := BAG(T)
    ; D := D(ctx, SetBagComp(vdecl, <get-typing-expr> D'){Type(U)}, U, T-BagComp(D'))


  // @type e -> M([D])
  infer-expr-x'(prune|sort*, map*, var*, ctx): e@SetEnum(e*) -> <or-error(|e, "Wrong item types")> D*
    with
      Ds* := <map(infer-expr-x(prune|sort*, map*, var*, ctx));fjoin(list-cart)> e*
    ; D* := <fmap(filter(infer-setenum-x(|ctx)))> Ds*

  // @type [D] ~> D
  infer-setenum-x(|ctx): D* -> D
    with
      T* := <map(get-typing-type)> D*
    where
      T := <fold1(lub)> T*
    with
      U := SET(T)
    ; D := D(ctx, SetEnum(<map(get-typing-expr)> D*){Type(U)}, U, T-SetEnum(D*))


  // @type e ~> M([D])
  infer-expr-x'(prune|sort*, map*, var*, ctx): e@FunApp(e1@DataRef(x), e*) -> <or-error(|e, "No matching functions/arguments")> D*
    where
      yT1* := <stdlib;getsome(where(?(x, _)))>
    with
      D2s* := <map(infer-expr-x(prune|sort*, map*, var*, ctx));fjoin(list-cart)> e*
    ; D* := <fjoin(join(infer-op-x(|ctx, e1)))> (yT1*, D2s*)

  // @type ((ID * Type) * [D]) ~> D
  infer-op-x(|ctx, e1): ((y, T1), D2*) -> D
    with
      T2* := <map(get-typing-type)> D2*
    where
      T1'@FUNCTION(_, T12) := <apply-scheme-x> (T1, T2*)
    with
      D1 := D(ctx, e1{Type(T1')}, T1', T-DataRef-Op())
    ; D := D(ctx, FunApp(<get-typing-expr> D1, <map(get-typing-expr)> D2*){Type(T12)}, T12, T-FunApp(D1, D2*))


  // @type e -> M([D])
  infer-expr-x'(prune|sort*, map*, var*, ctx): e@FunApp(e1, e2*) -> <or-error(|e, "No matching functions/arguments")> D*
    with
      D1* := <infer-expr-x(prune|sort*, map*, var*, ctx)> e1
    ; D2s* := <map(infer-expr-x(prune|sort*, map*, var*, ctx));fjoin(list-cart)> e2*
    ; D* := <fjoin(join(infer-app-x(|ctx)))> (D1*, D2s*)

  // @type (D, [D]) ~> D
  infer-app-x(|ctx): (D1, D2*) -> D
    with
      [T1|T2*] := <map(get-typing-type)> [D1|D2*]
    where
      FUNCTION(T11*, T12) := T1
    ; <subtypes> (T2*, T11*)
    with
      D := D(ctx, FunApp(<get-typing-expr> D1, <map(get-typing-expr)> D2*){Type(T12)}, T12, T-FunApp(D1, D2*))


  // @type e -> M([D])
  infer-expr-x'(prune|sort*, map*, var*, ctx): e@ForAll(vdecls, e') -> <or-error(|e, "Wrong type for body")> D*
    with
      xT* := <map(varsdecl-to-vars(|sort*));concat> vdecls
    ; ctx' := [xT*|ctx]
    ; D'* := <infer-expr-x(prune|sort*, map*, var*, ctx')> e'
    ; D* := <fmap(filter(infer-forall-x(|ctx, vdecls)))> D'*

  // @type D ~> D
  infer-forall-x(|ctx, vdecls): D' -> D
    with
      T' := <get-typing-type> D'
    where
      <subtype> (T', BOOL())
    with
      T := BOOL()
    ; D := D(ctx, ForAll(vdecls, <get-typing-expr> D'){Type(T)}, T, T-ForAll(D'))


  // @type e -> M([D])
  infer-expr-x'(prune|sort*, map*, var*, ctx): e@Exists(vdecls, e') -> <or-error(|e, "Wrong type for body")> D*
    with
      xT* := <map(varsdecl-to-vars(|sort*));concat> vdecls
    ; ctx' := [xT*|ctx]
    ; D'* := <infer-expr-x(prune|sort*, map*, var*, ctx')> e'
    ; D* := <fmap(filter(infer-exists-x(|ctx, vdecls)))> D'*

  // @type D ~> D
  infer-exists-x(|ctx, vdecls): D' -> D
    with
      T' := <get-typing-type> D'
    where
      <subtype> (T', BOOL())
    with
      T := BOOL()
    ; D := D(ctx, Exists(vdecls, <get-typing-expr> D'){Type(T)}, T, T-Exists(D'))


  // @type e -> M([D])
  infer-expr-x'(prune|sort*, map*, var*, ctx): e@Lambda(vdecls, e') -> <or-error(|e, "Wrong type for body")> D*
    with
      xT1* := <mapconcat(varsdecl-to-vars(|sort*))> vdecls
    ; T1* := <map(Snd)> xT1*
    ; ctx' := [xT1*|ctx]
    ; D'* := <infer-expr-x(prune|sort*, map*, var*, ctx')> e'
    ; D* := <fmap(filter(infer-lam-x(|ctx, vdecls, T1*)))> D'*

  // @type D ~> D
  infer-lam-x(|ctx, vdecls, T1*): D' -> D
    with
      T' := <get-typing-type> D'
    ; T := FUNCTION(T1*, T')
    ; D := D(ctx, Lambda(vdecls, <get-typing-expr> D'){Type(T)}, T, T-Lambda(D'))


  // @type e -> M([D])
  infer-expr-x'(prune|sort*, map*, var*, ctx): e@Where(e1, a*) -> <or-error(|e, "Type error")> D*
    with
      (x*, e2*) := <map(\ Assign(x, e2) -> (x, e2) \);unzip> a*
    ; D2s* := <map(infer-expr-x(prune|sort*, map*, var*, ctx));fjoin(list-cart)> e2*
    ; D* := <fmap(map(infer-whr-x(prune|sort*, map*, var*, ctx, x*, e1)));fmap(fjoin(concat))> D2s*

  // @type [D] -> M([D])
  infer-whr-x(prune|sort*, map*, var*, ctx, x*, e1): D2* -> <or-error(|e1, "Type error")> D*
    with
      T2* := <map(get-typing-type)> D2*
    ; ctx' := <conc> (<zip> (x*, T2*), ctx)
    ; D1* := <infer-expr-x(prune|sort*, map*, var*, ctx')> e1
    ; D* := <fmap(filter(infer-whr-x-typing(|ctx, x*, D2*)))> D1*

  // @type D -> D
  infer-whr-x-typing(|ctx, x*, D2*):
      D1 -> D( ctx
              , Where( <get-typing-expr> D1
                , <zip(\ (x, D2) -> Assign(x, <get-typing-expr> D2) \)> (x*, D2*)
                ){Type(T1)}
              , T1
              , T-Where(D1, D2*)
              )
    with
      T1 := <get-typing-type> D1
    ; T2* := <map(get-typing-type)> D2*


  // @type e -> M([D])
  infer-expr-x'(prune|sort*, map*, var*, ctx): As(e, S) -> <or-error(|e, "Cast error")> D*
    with
      D'* := <infer-expr-x(prune|sort*, map*, var*, ctx)> e
    ; if T := <sortref-to-type(|sort*)> S then
        D* := <fmap(filter(infer-as-x(|S, ctx, T)))> D'*
      else
        D* := []
      end

  // @type D ~> D
  infer-as-x(|srt, ctx, T): D' -> D
    with
      T' := <get-typing-type> D'
    where
      <subtype> (T', T)
    with
      D := D(ctx, As(<get-typing-expr> D', srt){Type(T)}, T, T-As(D'))

rules

  apply-scheme-x: (T1, T2*) -> T1''
    where
      T1'@FUNCTION(T11*, _) := <polarize-scheme> T1
    ; C := <zip;init-subtypes> (T2*, T11*)
    ; (C', sbs) := <gc-constraint-store(all-vars,polarity,gc-substitute,pp-partial-mcrl2typecheck-string|[])> C
    ; sbs' := <unify(is-var)> sbs
    ; T1'' := <substitute(|sbs')> T1'
